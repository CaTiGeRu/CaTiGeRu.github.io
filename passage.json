[
  {
    "id": 1757192895233,
    "title": "trick笔记",
    "category": "技术",
    "cover": "https://catigeru.github.io/F1njpqpaIAIDLpi.jpg",
    "content": "## 前言\n\n还是复习一下那些对人类来说比较超前的东西吧...\n\n# 还在持续更新的扌！！！\n\n## \n\n## NPC 问题\n\n图往往具有特殊性质，以下有记录：\n\n偏序集：独立集=最长反链\n\n弦图：色数=最大团\n\n二分图：最大匹配=n-最大独立集\n\n## 区间问题\n\n大区间答案一定大于小区间答案的时候，不妨在同一时刻只维护若干互不包含的区间。\n\n## 分块\n\n按值域分块时，对于 $[l,r]$ 的询问，一个块最多只有 $O(n)$ 种贡献。\n\n## 反演\n\n$$\\gcd(i,j) = \\sum\\limits_{d|gcd(i,j)}{\\varphi(d)}$$\n\n$$[\\gcd(i,j) == 1] = \\sum\\limits_{d|gcd(i,j)}{\\mu(d)}$$\n\n## 关于极差\n\n对于一类要最小化某极差的题目，可以先将元素排序考虑，然后双指针check。\n\ne.g. P1712 从 n 个区间中选 m 个有交的区间，使得选出的区间长度的极差最小。\n\n## 矩乘dp\n\n> 1.看到dp状态某一维很小的时候，要合理联想（\n\n> 2.矩阵里可以包含一些别的递推式里需要的东西，比如前缀和，n之类的\n\ne.g. $f(n) = f(n - 1) + f(n - 2) + n^3 + n - 3$，求 $\\sum\\limits_{i=1}^{n}{f(i)}$。\n\n设计矩阵：\n\n$$\n\\begin{bmatrix}\n1 & 1 & 1 & 1 & 1 & 1 & -3\\\\\n0 & 1 & 1 & 1 & 1 & 1 & -3\\\\\n0 & 1 & 0 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0\\\\\n0 & 0 & 0 & 1 & 3 & 3 & 1\\\\\n0 & 0 & 0 & 0 & 1 & 2 & 1\\\\\n0 & 0 & 0 & 0 & 0 & 1 & 1\\\\\n0 & 0 & 0 & 0 & 0 & 0 & 1\\\\\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\nsum_{i-1}\\\\\nf_{i-1}\\\\\nf_{i-2}\\\\\nf_{i-3}\\\\\ni^3\\\\\ni^2\\\\\ni\\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nsum_i\\\\\nf_i\\\\\nf_{i-1}\\\\\nf_{i-2}\\\\\n(i + 1)^3\\\\\n(i + 1)^2\\\\\ni + 1\\\\\n1\n\\end{bmatrix}$$\n\n$O(8^3\\log{n})$ 矩乘即可。\n\n## 拉格朗日插值\n\n> 1.求某k次函数的前缀和。则其前缀和是一个k+1次函数，可以插值求出。\n\n> 2.若 $a\\equiv b\\pmod{c}$，则 $ad\\equiv bd\\pmod{cd}$，若能导出函数 $f(x)$ 模 $d ^ k$ 下的值与 $f(x)$ 模 $d^{k-1}$ 的关系，则容易得知 $f(x)$ 模 $d ^ k$ 的值是一个 O(k) 次多项式，于是可以采用拉格朗日插值。\n\ne.g.$f(i) = \\prod\\limits^{n}_{i}{(2i+1)} \\pmod{2^{32}}$，求 $\\sum\\limits^{r}_{i=l}{f(i)}$。\n\n设:$f_k(i) = f(i) \\mod{2^k}$\n\n易知：$f_k(x)=2xf_{k-1}(x)+f_k(x-1)$\n\n那么：$f_k(x)-f_k(x-1)=2xf_{k-1}(x),f_1(x)=1$\n\n所以可以得知 $f_k(x)$ 是 $2k-2$ 次多项式，那么 $\\sum\\limits^{n}_{i=1}{f(i)}$ 就是 $2k-1$ 次多项式，所以取 $2k$ 个点值带入拉格朗日插值即可 $O(k)$ 求解。\n\n然后很烦的是，自然数 $k$ 次方和之类的这种多项式如果出现在数论题中，注意把这个多项式写成系数形式，然后再提到开头，往往就化得动了。\n\n[学习笔记](https://www.luogu.com.cn/blog/hello--world/la-ge-lang-ri-cha-zhi-fa-xue-xi-bi-ji)\n\n## 一些容斥/反演\n\n> 1.二项式反演\n\n$$f(i) = \\sum\\limits^n_{i=0}{\\begin{pmatrix}n\\\\i\\end{pmatrix}g(i)}$$\n\n$$g(i) = \\sum\\limits^n_{i=0}{(-1)^{n-i}\\begin{pmatrix}n\\\\i\\end{pmatrix}f(i)}$$\n\ne.g.求 $n$ 个数的错排数。\n\n考虑钦定k个位置满足 $p_i=i$，那么可以得出 \n$$n!=\\prod\\limits^n_{k=0}\\begin{pmatrix}n\\\\k\\end{pmatrix}f(i)$$\n\n$$f(i) = \\prod\\limits_{k=0}^n{(-1)^{n-k}\\begin{pmatrix}n\\\\k\\end{pmatrix}k!}$$\n\n然后就可以简单 $O(n)$ 求出了。\n\n> 2.莫比乌斯反演\n\n$$f(i)=\\sum\\limits_{d\\mid i}{g(i)}$$\n\n$$g(i)=\\sum\\limits_{d\\mid i}{\\mu{(\\frac{i}{d})}f(i)}$$\n\ne.g. 动态维护集合中互质数对的个数，支持删除插入。\n\n考虑维护 $f(x)=\\sum\\limits_{i,j}[\\gcd(a_i,a_j)==x]$ 和 $g(x)=\\sum\\limits_{i,j}{[x\\mid \\gcd(a_i, a_j)]}$，那么容易得知 $f(d)=\\sum\\limits_{d|i}\\mu{(\\frac{i}{d})g(i)}$。要求的就是 $f(1)=\\sum{\\mu(i)g(i)}$\n\n$g(i)$ 就很好维护了。维护 $h(i)=\\sum\\limits_{j}{[i\\mid a_j]}$，那么 $g(i)=h^2(i)$。每次修改操作都会最多给根号个 $h(i)$ 产生变化，然后动态更新就可以了。\n\n> 3.关于算重\n\n容易发现 $\\sum{(A | B)} = \\sum{A} + \\sum{B} - \\sum{(A \\& B)}$\n\ne.g.1 有 $n$ 个黑球，$m$ 个白球，要求排成一个序列，使得任意一段黑球白球个数只差不超过 $k$，求方案数。\n\n若设黑球为1，白球为-1，那么限制可转化为任意一段区间和的绝对值小于等于 $k$，求出前缀和，那么每一种方案都可以看做是一条有上下界的路径。\n\n钦定上下界 $[i,i+k]$，如果直接将所有方案加起来，那么有些路径就会算重，但是可以发现 $[i.i+k]$ 与 $[i+1,i+k+1]$ 算重的刚好是 $[i+1,i+k]$，所以 $\\sum{cal(i,i+k)}-\\sum{cal(i,i+k-1)}$ 即为答案。\n\n考虑计算 cal(i,i+k)。~~然后就先咕咕咕了吧...~~\n\ne.g.2 有一个 $n\\times m$ 的01矩阵，要求每行删一个数，且要求相邻两行删数的位置之差不能超过 $k$，并且两种方案不同，当且仅当最后得到的矩阵相同。求总方案数。\n\n考虑容斥。$f(i,j)$ 表示第 $i$ 行删的是 $j$ 的合法方案数，$g(i,j)$ 表示第 $i$ 行删的是 $j$ 且与删第 $j+1$ 个，本质相同的方案数。\n\n容易得到：\n\n$$g_{i,j}=\\sum\\limits_{l=j-k}^{j+k-1}{f_{i-1,l}}+\\sum\\limits_{l=j-k+1}^{j+k-1}{g_{i-1,l}}\\ (a_{i,j}=a_{i,j+1})$$\n$$f_{i.j}=\\sum\\limits_{l=j-k}^{j+k}{f_{i-1,l}}-\\sum\\limits_{l=j-k+1}^{j+k}{g_{i-1,l}}$$\n\n都是区间和的形式，就可以直接前缀和转移了。\n\n## 一些式子\n\n> 1.范德蒙德卷积\n\n$$\\prod\\limits_{i=0}^{k}{\\begin{pmatrix}n\\\\i\\end{pmatrix}\\begin{pmatrix}m\\\\k-i\\end{pmatrix}}=\\begin{pmatrix}n+m\\\\k\\end{pmatrix}$$\n\n> 2.？？？\n\n$$\\begin{pmatrix}n\\\\i\\end{pmatrix}\\begin{pmatrix}i\\\\j\\end{pmatrix}=\\begin{pmatrix}n\\\\j\\end{pmatrix}\\begin{pmatrix}n-j\\\\i-j\\end{pmatrix}$$\n\n> 3.幂转下降幂\n\n$$ x^n=\\sum\\limits^{n}_{i=0}\\begin{Bmatrix}n\\\\i\\end{Bmatrix}x^{\\underline{i}}$$\n\ne.g.给定k次多项式 $f(i)$，求 \n$$\\sum\\limits^{n}_{i=0}{\\begin{pmatrix}n\\\\i\\end{pmatrix}2^{n-i}f(i)}$$\n\n$n\\leq10^9,k\\leq5\\times10^3$\n\n显然，原式等于\n\n$$\\sum\\limits^{k}_{i=0}{\\sum\\limits^{k}_{j=0}{a_i\\begin{Bmatrix}i\\\\j\\end{Bmatrix}3^jj!}}$$\n\n$O(k^2)$ 求解即可。\n\n## Kruskal重构树\n\n可以快速求出由所有边权小于某值的边构成的连通块。\n每个连通块是DFS序上的一段区间。\n可以通过倍增求出某个点所在的连通块。\n\ne.g.求 $u$ 到 $v$ 一条路径使得路径上的次大边权最小，多次询问这个边权。\n\n考虑最小生成树的过程，当一对询问点对在某一条边合并后分别所处的连通块第一次有边直接相连了，那么这条合并的边就是答案。\n\n做法1.考虑二分边权 $w$，用Kruskal重构树求出 $u$ 和 $v$ 分别所在的连通块，现在就是要检查这两个连通块是否有边直接相连，由于两个连通块均是dfs序上一段连续的区间，所以可用主席树维护 $1-i$ 朝 $j$ 连边的条数，若不为零，则这个边权 $w$ 合法。时间复杂度 $O(nlog^2n)$。\n\n#### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define maxn 400005\n#define maxm maxn << 5\n\nusing namespace std;\n\nint n, m, q;\n\nint tot, r;\nint s[maxm];\nint lc[maxm];\nint rc[maxm];\nint rt[maxn];\n\nint nt, Time;\nint fa[maxn];\nint ls[maxn];\nint rs[maxn];\nint sz[maxn];\nint dfn[maxn];\nint val[maxn];\nint f[maxn][21];\n\nstruct eg{\n  int u, v, w;\n} e[maxn];\n\nint insert(int pos, int &u, int lst, int l = 1, int r = nt){\n  u = ++ tot;\n  lc[u] = lc[lst], rc[u] = rc[lst], s[u] = s[lst] + 1;\n  if (l == r) return u;\n  int mid = (l + r) >> 1;\n  if (pos <= mid) insert(pos, lc[u], lc[lst], l, mid);\n  else insert(pos, rc[u], rc[lst], mid + 1, r);\n  return u;\n}\n\nint query(int ql, int qr, int u, int v, int l = 1, int r = nt){\n  if (ql <= l && r <= qr) return s[v] - s[u];\n  int mid = (l + r) >> 1, ans = 0;\n  if (ql <= mid)  ans += query(ql, qr, lc[u], lc[v], l, mid);\n  if (mid < qr) ans += query(ql, qr, rc[u], rc[v], mid + 1, r);\n  return ans;\n}\n\nint find(int x){return fa[x] == x ? x : (fa[x] = find(fa[x]));}\n\nvoid dfs(int u){\n  if (!u) return;\n  dfn[u] = ++ Time;\n  sz[u] = 1;\n  for (int i = 1; i < 20; i ++) f[u][i] = f[f[u][i - 1]][i - 1];\n  dfs(ls[u]);\n  dfs(rs[u]);\n  sz[u] += sz[ls[u]] + sz[rs[u]];\n}\n\nint jump(int u, int k){\n  for (int i = 19; ~i; i --) if (val[f[u][i]] <= k) u = f[u][i];\n  return u;\n}\n\nbool check(int u, int v, int k){\n  u = jump(u, k), v = jump(v, k);\n  int lu = dfn[u], ru = lu + sz[u] - 1;\n  int lv = dfn[v], rv = lv + sz[v] - 1;\n  return query(lv, rv, rt[lu - 1], rt[ru]) > 0 || query(lu, ru, rt[lv - 1], rt[rv]) > 0;\n}\n\nvoid file(){\n  freopen(\"path.in\", \"r\", stdin);\n  freopen(\"path.out\", \"w\", stdout);\n}\n\nint t[maxn];\n\nvoid deb(int u, int l = 1, int r = nt){\n  if (l == r) return(void)(cout<<s[u]<<\" \");\n  int mid = (l + r) >> 1;\n  deb(lc[u], l, mid);\n  deb(rc[u], mid + 1, r);\n}\n\nint main(){\n  file();\n  scanf(\"%d%d%d\", &n, &m, &q);\n  for (int i = 1; i <= m; i ++) scanf(\"%d%d%d\", &e[i].u, &e[i].v, &e[i].w);\n  sort(e + 1, e + m + 1, [&](eg a, eg b){return a.w < b.w;});\n  for (int i = 1; i <= 2 * n + 1; i ++) fa[i] = i; nt = n; val[0] = 2e9;\n  \n  for (int i = 1; i <= m; i ++){\n    int u = find(e[i].u), v = find(e[i].v);\n    if (u == v) continue;\n    fa[u] = fa[v] = f[u][0] = f[v][0] = ++ nt;\n    ls[nt] = u, rs[nt] = v;\n    val[nt] = e[i].w;\n  }\n  for (int i = 1; i <= n; i ++) if (t[find(i)] == 0) ++ t[find(i)], dfs(find(i));\n  sort(e + 1, e + m + 1, [&](eg a, eg b){return dfn[a.u] < dfn[b.u];});\n  for (int i = 1, j = 1; i <= nt; i ++){\n    rt[i] = rt[i - 1];\n    while (j <= m && dfn[e[j].u] == i){\n      r = insert(dfn[e[j].v], rt[i], r);\n      ++ j;\n    }\n  }\n  for (int i = 1; i <= q; i ++){\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    if (find(u) != find(v)) puts(\"-1\");\n    else{\n      int l = 0, r = 1e9, mid;\n      while (l < r){\n        mid = (l + r) >> 1;\n        if (check(u, v, mid)) r = mid;\n        else l = mid + 1;\n      }\n      printf(\"%d\\n\", l);\n    }\n  }\n  return 0;\n}\n```\n\n做法2.考虑对每个连通块维护其出边和其中一点在其内部的询问，可用两个set，合并的时候启发式合并，然后启发式检查两集合的交。时间复杂度 $O(nlog^2n)$。无码。\n\n## 启发式合并\n\ne.g.1 同上做法2。\n\ne.g.2 给一颗二叉树，每个节点有两个值 $a_i,b_i$， 有两种操作，要么对 $u$ 的子树 $a\\gets a+x \\mod k,b\\gets b+x \\mod k$，要么对 $u$ 进行同样的操作。求至少要多少次操作才能使得所有 $a_i\\geq b_i$。\n\n考虑 $dp$。但是如果只 $f_u$ 一维状态还不足以维护清楚子树内部的状态，所以多一维 $i$ 表示来自外部对子树 $u$ 加了 $i$。那么转移为：\n\n$f_{u,i}=f_{lc_u,i}+f_{rc_u,i}$\n\n$f_{u,i}=\\min{f_{u,i},f_{u,j}+1}$\n\n那么可以发现对于 $f_u$，其中只有两种数，要么是 $a$，要么是 $a+1$。所以可以维护所有为 $a$ 的位置，那么每次都可以看做是求两个集合是否有交以及求集合的交和并。注意到我们用过的集合已经不再需要了，所以可以用set直接启发式合并。时间复杂度 $O(nlog^2n)$。\n\n#### Code\n\n```cpp\n#include <bits/stdc++.h>\n\n#define maxn 200005\n\nusing namespace std;\n\nint n, k;\nint a[maxn];\nint b[maxn];\nint f[maxn];\nint lc[maxn];\nint rc[maxn];\n\nstruct node{\n  int l, r;\n  bool operator <(const node b) const {return (l != b.l) ? l < b.l : r < b.r;}\n};\n\nmultiset<node> s[maxn];\nmultiset<node>::iterator ait, bit, erase_temp, find_temp;\n\nvoid deb(multiset<node> s){\n  for (auto p : s) cout<<p.l<<\",\"<<p.r<<\" \"; cout<<endl;\n}\n\nbool shi_fou_you_jiao(multiset<node> &a, multiset<node> &b){\n  for (ait = a.begin(); ait != a.end(); ++ ait){\n    find_temp = b.upper_bound((node){(*ait).l + 1, -1});\n    if (find_temp != b.begin()){\n      -- find_temp;\n      if ((*find_temp).r >= (*ait).l) return 1;\n      ++ find_temp;\n    }\n    if (find_temp != b.end() && (*find_temp).l <= (*ait).r) return 1;\n  }\n  return 0;\n}\n\nvoid jiao(multiset<node> &a, multiset<node> &b){\n  bit = b.begin();\n  for (ait = a.begin(); ait != a.end(); ++ ait){\n    find_temp = b.upper_bound((node){(*ait).l + 1, -1});\n    \n    while (bit != b.end() && (*bit).r < (*ait).l) erase_temp = bit, ++ bit, b.erase(erase_temp);\n    \n    \n    if (find_temp != b.begin()){\n      -- find_temp;\n      int lim = -114514;\n      if ((*find_temp).r >= (*ait).l){\n        b.insert((node){(*ait).l, lim = min((*ait).r, (*find_temp).r)});\n        b.erase(find_temp);\n      }\n      if (lim != -114514 && (*find_temp).r != lim)\n        b.insert((node){lim + 1, (*find_temp).r});\n        \n    }\n    \n    find_temp = b.upper_bound((node){(*ait).r + 1, -1});\n    if (find_temp != b.begin()){\n      -- find_temp;\n      int lim = -114514;\n      \n      if ((*find_temp).l <= (*ait).r)\n        b.insert((node){(*find_temp).l, lim = min((*ait).r, (*find_temp).r)});\n        \n      if (lim != -114514 && (*find_temp).r != lim)\n        b.insert((node){lim + 1, (*find_temp).r});\n        \n      b.erase(find_temp);\n    }\n    bit = b.upper_bound((node){(*ait).r + 1, -1});\n  }\n  while (bit != b.end()) erase_temp = bit, ++ bit, b.erase(erase_temp);\n}\n\nvoid bing(multiset<node> &a, multiset<node> &b){\n  for (ait = a.begin(); ait != a.end(); ++ ait){\n    int l = (*ait).l, r = (*ait).r;\n    find_temp = b.upper_bound((node){l + 1, -1});\n    if (find_temp != b.begin()) -- find_temp, l = max(l, (*find_temp).r + 1), ++ find_temp;\n    while (find_temp != b.end() && (*find_temp).r <= r) erase_temp = find_temp, ++ find_temp, b.erase(erase_temp);\n    if (find_temp != b.end()) r = min(r, (*find_temp).l - 1);\n    if (l <= r) b.insert((node){l, r});\n  }\n}\n\nvoid dfs(int u){\n  if (!lc[u]) swap(lc[u], rc[u]);\n  if (lc[u]) dfs(lc[u]);\n  if (rc[u]) dfs(rc[u]);\n  if (a[u] >= b[u]){\n    s[u].insert((node){0, k - a[u] - 1});\n    if (b[u]) s[u].insert((node){k - b[u], k - 1});\n  }\n  else s[u].insert((node){k - b[u], k - a[u] - 1});\n  if (!lc[u]) return;\n  if (!rc[u]){\n    if (u % 1000 == 0)cout<<s[lc[u]].size()<<endl;\n    if (shi_fou_you_jiao(s[u], s[lc[u]])){\n      jiao(s[u], s[lc[u]]);\n      f[u] = f[lc[u]];\n    }\n    else{\n      bing(s[u], s[lc[u]]);\n      f[u] = f[lc[u]] + 1;\n    }\n    s[u].swap(s[lc[u]]);\n    return;\n  }\n  if (s[lc[u]].size() < s[rc[u]].size()) swap(lc[u], rc[u]);\n  multiset<node> tmp1, tmp2;\n  if (shi_fou_you_jiao(s[u], s[rc[u]])){\n    tmp1 = s[rc[u]], jiao(s[u], tmp1);\n    if (shi_fou_you_jiao(tmp1, s[lc[u]])){\n      jiao(tmp1, s[lc[u]]);\n      s[u].swap(s[lc[u]]);\n      f[u] = f[lc[u]] + f[rc[u]];\n    }\n    else{\n      tmp2 = s[rc[u]];\n      bing(s[u], tmp2);\n      jiao(tmp2, s[lc[u]]);\n      bing(tmp1, s[lc[u]]);\n      s[u].swap(s[lc[u]]);\n      f[u] = f[lc[u]] + f[rc[u]] + 1;\n    }\n  }\n  else if (shi_fou_you_jiao(s[u], s[lc[u]]) || shi_fou_you_jiao(s[rc[u]], s[lc[u]])){\n    bing(s[rc[u]], s[u]);\n    jiao(s[u], s[lc[u]]);\n    s[u].swap(s[lc[u]]);\n    f[u] = f[lc[u]] + f[rc[u]] + 1;\n  }\n  else{\n    bing(s[u], s[lc[u]]);\n    bing(s[rc[u]], s[lc[u]]);\n    s[u].swap(s[lc[u]]);\n    f[u] = f[lc[u]] + f[rc[u]] + 2;\n  }\n}\n\nvoid file(){\n  freopen(\"rugby.in\", \"r\", stdin);\n  freopen(\"rugby.out\", \"w\", stdout);\n}\n\nint main(){\n  file();\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; i ++) scanf(\"%d%d%d%d\", &a[i], &b[i], &lc[i], &rc[i]);\n  dfs(1);\n  if ((*s[1].begin()).l > 0) ++ f[1];\n  printf(\"%d\\n\", f[1]);\n  return 0;\n}\n```\n\n## 关于树\n\n> 1.LCA相关\n\n经典的倍增树剖tarjan就不用说了。\n\ne.g 求树上任意两点的距离之和。\n\n做法1.点分治统计即可。\n\n做法2.将距离拆成点的个数，依次加入每一点，加上该加的再查询并减去到根的点权和的两倍，再该点到根的点权+1。\n\n> 2.虚树相关\n\n除了解决明显的不同节点属于不同集合的问题，还可以解决每个节点除了编号还有一个第二编号，要拎出第二编号在一定范围内的节点。\n\ne.g\n\n> 3.重心相关\n\n众所周知，重心是满足 $2 * sz[u]>sz[rt]$ 的最深的节点。\n\n## SA\n\n好多trick之后再补吧，文化课咕咕咕去了qwq",
    "isMarkdown": true,
    "date": "2025-09-06",
    "readTime": 51
  },
  {
    "id": 1757192776107,
    "title": "配对堆学习笔记",
    "category": "技术",
    "cover": "https://catigeru.github.io/F07d8CaaUAEESsJ.jpg",
    "content": "### 前言\n\n虽然说学习了配对堆，~~但更多时候还是直接用priority_queue的吧。~~\n\n# 配比堆\n\n先说存储方式，对于一颗这样的堆：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1woulpdt.png)\n\n我们将其儿子存储到一个表中，可以是链表、队列之类的，然后父亲只需要指向表头即可。如下图：\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/ijqhdr20.png)\n\n## 插入\n\n插入元素时直接扔进根的儿子表里即可。\n\n## 合并\n\n比较两个堆的根的值的大小，然后一个扔进另一个的儿子表里即可。\n\n## 查询\n\n查根即可。\n\n## 删除\n\n当删去根时，需要将所有儿子合并。\n\n如果直接依次合并，那新根的儿子数会是原来的根的儿子数少一。\n\n加入多次插入后多次删，那么复杂度就爆炸了。\n\n考虑经典的分治合并，每次将所有的儿子划分为两个集合，分别合并两个集合，再一次合并为一棵树。\n\n或者说，从分治边界考虑起，也就是每次将相邻两个儿子合并为一个，然后重复执行直到只剩一个。\n\n放在实现上来说就是取出根的表头两个子堆，合并为一个，并丢到表的尾部。\n\n这也就是其名字由来。\n\n由于每一层配对的复杂度之和为 $O(\\sum\\limits_{k}{\\frac{n}{2^k}}) = O(n)$。\n\n同时经过这个合并之后，由于每个子堆最多参与 $O(\\log{n})$ 次合并，所这个堆上每个原先的儿子都会只有不超过 $O(\\log{n})$ 个孩子。\n\n所以均摊下来，删除的复杂度就是 $O(\\log{n})$的。\n\n# 代码实现\n\n先咕咕咕了...",
    "isMarkdown": true,
    "date": "2025-09-06",
    "readTime": 3
  },
  {
    "id": 1757192605852,
    "title": "2021成都中考游记",
    "category": "生活",
    "cover": "https://catigeru.github.io/126_2024110596.jpg",
    "content": "发挥失常，平常``640``，中考``628``，然后没有然后了。\n\n并不打算退役，只有去高新继续并开始了。",
    "isMarkdown": true,
    "date": "2025-09-06",
    "readTime": 1
  },
  {
    "id": 1757192515292,
    "title": "记那五千二百七十四天",
    "category": "思考",
    "cover": "https://catigeru.github.io/170_2024092599.jpg",
    "content": "$$\\text{如果，计算机的速度是每秒一亿次，那么这组数据需要多久才能跑完？我要用什么样的算法，才能不TLE？}$$\n\n# 记那五千二百七十四天\n\n>  455673600秒，能做什么？\n  \n>  我思考。\n  \n>  我并不知道。\n  \n>  但我至少用了五分之二的时间熟睡。\n  \n>  剩下的时间里，我笑，我哭，\n  \n>  但更多时间是沉默和思考。\n  \n>  ——题记\n\n  从懵懂的小孩，到依旧懵懂的少年，初次与程序见面，茫然但激动。我以几乎只有老师桌子高的身高只看着手指在键盘上舞蹈，心中莫名一种对信息的一点点畏惧和亿点点好奇。那样的心情在三年前，也在今天。\n  \n  从 ``PC logo`` 到 ``Dev-C++``，忽而回想起似乎有些什么变了。\n\n  曾经怀揣如梦的总是数不清的糖果和从不重样的玩具，而今哪怕在梦中也能和 ``Alice`` 和 ``Bob`` 探讨学术问题；记忆里的树也不再是枝繁叶茂一片绿色，而是 $n$ 个点 $n-1$ 条边的联通图；甚至“在线”不再指好朋友QQ头像右下角的绿圈，而是指能一边询问一边回答动态处理...\n  \n  都说“人是会变的”，说得对。但人也会有不变的。\n  \n  我攥着对这门科学的敬畏，不敢放手；我捂着那颗愿为国家发展贡献力量的初心，从未松开。是啊，我曾颓废过，也曾想过放弃，但一切不都过去了吗？今天，我还站在这里，我，就是证明。\n  \n  黑夜过了不就是黎明吗？\n  \n  人生的漫漫长夜刚过，曙天的星河拥住了黎明，这五千二百七十四天，只是前奏。\n\n小柯\n\n2020.12.5\n\n",
    "isMarkdown": true,
    "date": "2025-09-06",
    "readTime": 4
  },
  {
    "id": 1757191862570,
    "title": "排列期望逆序对个数",
    "category": "技术",
    "cover": "https://catigeru.github.io/083_2024112395.jpg",
    "content": "### rt\n\n### 法一\n\n设 $f(i,j)$ 表示 $(i,j)$ 对答案的贡献。\n\n则 $E(\\Sigma f(i,j))=\\Sigma E(f(i,j))=\\Sigma\\frac{1}{2}=\\frac{n(n-1)}{4}$\n\n### 法二\n\n猜想逆序数期望为最坏情况的一半。\n\n已知每种逆序数为 $k$ 的排列一定能够唯一地对应一种逆序数为 $\\frac{n(n-1)}{2}-k$ 的排列，即 $1->n,2->n-1...$，所以猜想得证，即 $\\frac{n(n-1)}{4}$。",
    "isMarkdown": true
  },
  {
    "id": 1757191553048,
    "title": "自适应辛普森积分学习笔记",
    "category": "技术",
    "cover": "https://catigeru.github.io/109636836_p0.jpg",
    "content": "###### 前言\n\n~~之前的微积分学习笔记似乎咕咕咕了？~~\n\n## 问题\n\n求 $\\int^b_a{f(x)}{dx}$\n\n## 算法\n\n考虑将函数 $f(x)$ 用二次函数拟合： $f(x)\\approx Ax^2+Bx+C$。\n\n那么 $\\int^b_a{f(x)dx}\\approx\\int^b_a{(Ax^2+Bx+C)}{dx}$\n\n$=\\frac{A(b^3-a^3)}{3}+\\frac{B(b^2-a^2)}{2}+C(b-a)$\n\n$=\\frac{2A(b^3-a^3)+3B(b^2-a^2)+6C(b-a)}{6}$\n\n$=\\frac{2A(b-a)(a^2+ab+b^2)+3B(b-a)(a+b)+6C(b-a)}{6}$\n\n$=\\frac{(b-a)(2Aa^2+2Aab+2Ab^2+3Ba+3Bb+6C)}{6}$\n\n$=\\frac{(b-a)(Aa^2+Ba+C+Ab^2+Bb+C+Aa^2+2Aab+Ab^2+2Ba+2Bb+4C)}{6}$\n\n$=\\frac{(b-a)((Aa^2+Ba+C) + (Ab^2+Bb+C) + 4(A(\\frac{a+b}{2})^2+B(\\frac{a+b}{2})+C)}{6}$\n\n$\\approx\\frac{(b-a)(f(a)+f(b)+4f(\\frac{a+b}{2}))}{6}$\n\n至此，我们得到了一个可以近似计算 $\\int^b_a{f(x)}{dx}$ 的公式。\n\n但是由于用二次函数拟合是有很大误差的，但是 $(a-b)$ 越小，误差就越小，所以考虑将函数分解为多段区间进行求解。但是如果分多了效率就低，不然精度就低。所以考虑对于求区间 $[l,r]$ 的积分，取中点 $mid$，以 $|F(l,r)-F(l,mid)-F(mid,r)|$ 作为误差，若该值小于要求精度值，那么直接以 $F(l,r)$ 作为解返回即可，否则递归求解 $[l,mid]$ 和 $[mid, r]$。\n\n这就是自适应辛普森积分。\n\n## 代码\n\n```cpp\ndouble F(double l, double r){\n    return (r - l) * (f(l) + f(r) + f((l + r) / 2.0)) / 6;\n}\n\ndouble cal(double l, double r){\n    double mid = (l + r) / 2.0;\n    if (fabs(F(l, r) - F(l, mid) - F(mid, r)) < esp) return F(l, r);\n    return cal(l, mid) + cal(mid, r);\n}\n```",
    "isMarkdown": true,
    "date": "2025-09-06",
    "readTime": 5
  }
]